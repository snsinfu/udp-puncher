package ecdh

import (
	"bytes"
	"testing"
)

func TestNew(t *testing.T) {
	key := []byte{
		0xac, 0x85, 0x2e, 0xef, 0x2e, 0x6d, 0x80, 0x7c,
		0x9b, 0xd8, 0xa3, 0x3e, 0x99, 0x6d, 0x39, 0xae,
		0x4d, 0x3d, 0x3e, 0x0b, 0xc0, 0xb6, 0x03, 0x28,
		0x75, 0xfe, 0x35, 0x6e, 0xc9, 0xcd, 0x18, 0x47,
	}
	r := bytes.NewReader(key)

	dh, err := New(r)
	if err != nil {
		t.Fatalf("unexpected error: %s", err)
	}

	if r.Len() != 0 {
		t.Errorf("key has not been read completely: %d bytes left", r.Len())
	}

	// [whitebox]
	if !bytes.Equal(dh.key[:], key) {
		t.Errorf("incorrect key: got %x, want %x", dh.key[:], key)
	}
}

func TestPrivateKey_Public(t *testing.T) {
	r := bytes.NewReader([]byte{
		0xac, 0x85, 0x2e, 0xef, 0x2e, 0x6d, 0x80, 0x7c,
		0x9b, 0xd8, 0xa3, 0x3e, 0x99, 0x6d, 0x39, 0xae,
		0x4d, 0x3d, 0x3e, 0x0b, 0xc0, 0xb6, 0x03, 0x28,
		0x75, 0xfe, 0x35, 0x6e, 0xc9, 0xcd, 0x18, 0x47,
	})

	dh, err := New(r)
	if err != nil {
		t.Fatalf("unexpected error: %s", err)
	}

	actual := dh.Public()
	expected := []byte{
		0x09, 0x20, 0x47, 0xed, 0x64, 0xa7, 0x18, 0x76,
		0x96, 0x38, 0x50, 0x78, 0x7f, 0x8f, 0x6c, 0x05,
		0xeb, 0x1a, 0x31, 0x54, 0xd0, 0xb7, 0xda, 0x03,
		0x57, 0x5f, 0x4b, 0xb6, 0x7b, 0xbf, 0xfc, 0x76,
	}

	if !bytes.Equal(actual, expected) {
		t.Errorf("got %x, want %x", actual, expected)
	}
}

func TestPrivateKey_ComputeSecret(t *testing.T) {
	r := bytes.NewReader([]byte{
		// Key 1
		0xac, 0x85, 0x2e, 0xef, 0x2e, 0x6d, 0x80, 0x7c,
		0x9b, 0xd8, 0xa3, 0x3e, 0x99, 0x6d, 0x39, 0xae,
		0x4d, 0x3d, 0x3e, 0x0b, 0xc0, 0xb6, 0x03, 0x28,
		0x75, 0xfe, 0x35, 0x6e, 0xc9, 0xcd, 0x18, 0x47,
		// Key 2
		0xee, 0xa0, 0x32, 0x39, 0x2f, 0x7a, 0x49, 0x9e,
		0x52, 0x85, 0x96, 0x2b, 0xcb, 0xbb, 0xde, 0xd5,
		0xab, 0xcf, 0x3c, 0xb2, 0xa8, 0x19, 0xa0, 0xb5,
		0x05, 0x06, 0x74, 0xcb, 0x68, 0x61, 0xca, 0x95,
	})

	dh1, err := New(r)
	if err != nil {
		t.Fatalf("unexpected error: %s", err)
	}

	dh2, err := New(r)
	if err != nil {
		t.Fatalf("unexpected error: %s", err)
	}

	actual1, err := dh1.ComputeSecret(dh2.Public())
	if err != nil {
		t.Fatalf("unexpected error: %s", err)
	}

	actual2, err := dh2.ComputeSecret(dh1.Public())
	if err != nil {
		t.Fatalf("unexpected error: %s", err)
	}

	expected := []byte{
		0x8a, 0x83, 0xdd, 0xe3, 0x0e, 0x0c, 0xf3, 0xa1,
		0x6c, 0x37, 0x3b, 0x4d, 0x28, 0xa0, 0x84, 0xbe,
		0x88, 0xd0, 0xab, 0xbb, 0x8c, 0xe3, 0x02, 0xb9,
		0x2b, 0xbe, 0x45, 0xae, 0xaf, 0x20, 0xd3, 0x57,
	}

	if !bytes.Equal(actual1, expected) {
		t.Errorf("got %x, want %x", actual1, expected)
	}

	if !bytes.Equal(actual2, expected) {
		t.Errorf("got %x, want %x", actual2, expected)
	}
}

func TestPrivateKey_ComputeSecret_DetectsInvalidPublicKey(t *testing.T) {
	r := bytes.NewReader(make([]byte, 32))

	dh, err := New(r)
	if err != nil {
		t.Fatalf("unexpected error: %s", err)
	}

	// Empty
	_, err = dh.ComputeSecret([]byte{})
	if err == nil {
		t.Errorf("unexpected success: %s", err)
	} else if err != ErrInvalidPublicKey {
		t.Errorf("unexpected error: %s", err)
	}

	// Short
	_, err = dh.ComputeSecret(make([]byte, 31))
	if err == nil {
		t.Errorf("unexpected success: %s", err)
	} else if err != ErrInvalidPublicKey {
		t.Errorf("unexpected error: %s", err)
	}

	// Long
	_, err = dh.ComputeSecret(make([]byte, 33))
	if err == nil {
		t.Errorf("unexpected success: %s", err)
	} else if err != ErrInvalidPublicKey {
		t.Errorf("unexpected error: %s", err)
	}
}
